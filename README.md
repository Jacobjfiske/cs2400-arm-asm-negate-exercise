# ARM Assembly Negate Exercise

MSUD, CS 2400, Spring 2019

## Requirements

### Preliminaries
1. Download and install [VisUAL](https://salmanarif.bitbucket.io/visual/downloads.html).
2. Find out what UAL means in the context of ARM syntax.
3. Review the instructions supported by VisUAL.

### Quick negate
1. Load the [short negate program](https://github.com/ivogeorg/cs2400-arm-asm-negate-exercise/blob/master/negate.S) into VisUAL (Use **Open** from the menu).
2. Execute the program. View the memory. (Use **Tools** from the menu.)
3. **QUESTION 0:** What does the program do?
4. Single-step the program and watch the registers, memory locations, and status flags change.

### Long negate
1. Load the [long negate program](https://github.com/ivogeorg/cs2400-arm-asm-negate-exercise/blob/master/negate_gcc_8_2.S) into VisUAL (Use **Open** from the menu).
2. Execute the program. View the memory. (Use **Tools** from the menu.)
3. Answer the following questions:
   1. **QUESTION 1:** What is the short program doing that the long program is not?
   2. **QUESTION 2:** Why do you think the compiler has generated such assembly code?
   3. **QUESTION 3:** How would you try to change the code so that the compiler would generate an assembly program that behaves more like the short one above? The original code is in [`negate.c`](https://github.com/ivogeorg/cs2400-arm-asm-negate-exercise/blob/master/negate.c). Modify it and see if that changes the generated code. (The code is generated in the [Compiler Explorer](https://godbolt.org). Use the **ARM gcc 8.2** compiler. Use the following compiler options: `-fomit-frame-pointer -mcpu=cortex-m3 -mtune=cortex-m3`. *Note: The assembly generated by the Compiler Explorer cannot be run directly in VisUAL. You might want to check the differences between the original generated code and the long negate program to see what modifications you have make.*)
4. Single-step the program and watch the registers, memory locations, and status flags change.
5. Modify the long program to do what the short one is doing.

### Submission
1. Fork this repository.
2. Clone and develop.
3. Commit your changes and push to the remote.
4. Submit your fork's URL on the Google Classroom assignment **CS 2400 - Classwork - ARM assembly negate exercise**.

### Answers
1. Answer 0: The short program negates all negative numbers in the array, in memory. Notice how sparing the code is, even without trying! The long program, in contrast, is generated by the compiler, observing large-project multiple-function stack-based execution heuristics.
2. Answer 1: The short program modifies the original data in the array. The long program does not.
3. Answer 2: The long program contains the `array` variable as a local in `main`. The compiler knows that all local data is lost, once the function's frame is taken off the stack. In the C program in `negate.c`, there is no code modifying global data, so the compiler does not bother to write the changes back to memory. 
4. Answer 3: If we take `array` out of `main` and declare it as a `static` global, as can be seen in `negate_glob_arr.c`, the compiler indeed generates code that writes back the modifications from the stack back to memory. You can check by executing the corresponding assembly file `negate_global_array.S` in VisUAL.
